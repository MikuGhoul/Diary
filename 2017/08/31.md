## Sort

### Example

* 待排序序列
    * 503 087 512 061 908 170 798 275 653 426
    * `a[i] <= a[i+1]` 

#### 直接插入排序

* 将**待排序数字**逐个插入**有序表**中，插入位置由从左到右（或从右到左）依次比较大小作为判断基准
* sort：假设以待排序序列的**第一个数字**作为**已排好**（粗体）的有序表。后续带排数字（斜体）逐个插入
    * **503** *087* 512 061 908 170 798 275 653 426
    * **087 503** *512* 061 908 170 798 275 653 426
    * **087 503 512** *061* 908 170 798 275 653 426
    * **061 087 503 512** *908* 170 798 275 653 426
    * **061 087 503 512 908** *170* 798 275 653 426
    * **061 087 170 503 512 908** *798* 275 653 426
    * **061 087 170 503 512 798 908** *275* 653 426
    * **061 087 170 275 503 512 798 908** *653* 426
    * **061 087 170 275 503 512 653 798 908** *426*
    * **061 087 170 275 426 503 512 653 798 908**

#### 希尔排序

* 将**待排序序列**划分为若干**子序列**（根据增量划分），子序列**各自分别**进行插入排序，待**基本有序**后，再重新划分子序列（增量减少），重复这个过程至增量为1
* sort：假设**增量**分别为5、3、1，则每次划分为间隔**5、3、1**为一个子序列
    * 503 087 512 061 908 170 897 275 653 426（增量为5，每个子序列划分如下）
        * 503 170
        * 087 897
        * 512 275
        * 061 653
        * 908 426
    * 170 087 275 061 426 503 897 512 653 908（增量为3，每个子序列划分如下）
        * 170 061 897 908
        * 087 426 512
        * 275 503 653
    * 061 087 275 170 426 503 897 512 653 908（增量为1，每个子序列划分如下）
        * 061
        * 087
        * 275
        * 170
        * 426
        * 503
        * 897
        * 512
        * 653
        * 908
    * 061 087 170 275 426 503 512 653 897 908

#### 冒泡排序

* 将最大或者最小的数字通过相邻数字的比较冒泡至顶部或者底部，然后将其移除待排序序列，对其余数字重复这个过程至只剩一个数字。
* sort：假设将小的数字冒泡至顶部
    * 503 087 512 061 908 170 798 275 653 426
    * **061** 503 087 512 908 170 798 275 653 426
    * **061 087** 503 512 908 170 798 275 653 426
    * **061 087 170** 503 512 908 798 275 653 426
    * **061 087 170 275** 503 512 908 798 653 426
    * **061 087 170 275 426** 503 512 908 798 653
    * **061 087 170 275 426 503** 512 908 798 653
    * **061 087 170 275 426 503 512** 908 798 653
    * **061 087 170 275 426 503 512 653** 908 798
    * **061 087 170 275 426 503 512 653 798** 908

#### 快速排序

* 设置三个指针，`low,high,flag`，low放在待排序列列首，high放在序列列尾。对比low或high与flag的大小。若low大于flag（或者high小于flag）则交换其与flag的位置并且high指针前移，然后再次比较，若high小于flag（或者low大于flag）则交换其与flag的位置并且low指针后移，重复至`low == high`，然后flag则会将序列划分为小于flag和大于flag的两部分，在对每个部分进行上述步骤
* sort：假设待排序列列首为low（斜体）和flag（粗斜体），尾为high（粗体），flag先比较high
    * ***503*** 087 512 061 908 170 897 275 653 **426**
        * 426 *087* 512 061 908 170 897 275 653 ***503***
        * 426 087 *512* 061 908 170 897 275 653 ***503***
        * 426 087 ***503*** 061 908 170 897 275 **653** 512
        * 426 087 ***503*** 061 908 170 897 **275** 653 512
        * 426 087 275 *061* 908 170 897 ***503*** 653 512
        * 426 087 275 061 *908* 170 897 ***503*** 653 512
        * 426 087 275 061 ***503*** 170 **897** 908 653 512
        * 426 087 275 061 ***503*** **170** 897 908 653 512
    * (***426*** 087 275 061 **170**) 503 (***897*** 908 653 **512**)
        * (170 *087* 275 061 ***426***) 503 (512 *908* 653 ***897***)
        * (170 087 *275* 061 ***426***) 503 (512 ***897*** **653** 908)
        * (170 087 275 *061* ***426***) 503 (512 653 ***897*** 908)
        * (170 087 275 061) 426 503 (***512*** **653**) 897 908
    * (***170*** 087 275 **061**) 426 503 (***512*** **653**) 897 908
        * (*061* 087 275 ***170***) 426 503 512 653 897 908
        * (061 *087* 275 ***170***) 426 503 512 653 897 908
        * (061 087 *275* ***170***) 426 503 512 653 897 908
        * (061 087 ***170*** 275) 426 503 512 653 897 908
    * (***061*** **087**) 170 275 426 503 512 653 897 908
    * 061 087 170 275 426 503 512 653 897 908
