## C++ 类
* part 2

#### 类的作用域
* 一个类就是一个作用域
* 在类外定义函数，一旦遇到了类名，定义的剩余部分（包括参数列表和函数体）就在类的**作用域之内**了
    * 类外定义的**函数的返回值**定义在类名之前，所以返回值在类的作用域之外，所以返回值要声明在那个类中
* 名字查找与作用域
    * 编译器处理完类中的**全部声明**之后才会处理**成员函数**

#### 构造函数再探
* 对象数据成员初始化/赋值
    * 初始值列表/函数体内赋值
    * 效率
        * 初始值列表直接初始化数据成员
        * 赋值则是先默认初始化再赋值
    * 必须用初始值列表的场景
        * 数据成员中有`const`或`引用`类型
* 成员初始化的顺序
    * 初始值列表中**初始化**的顺序与在**类定义**中出现的顺序一致
* 默认实参的构造函数
    * 如果形参列表为所有参数都提供了默认实参，那实际上这也是一个**默认构造函数**
* 委托构造函数
    * 本质就是构造函数调用构造函数
* 隐式的**类**类型转换
    * **转换构造函数**
        * 如果构造函数只接受一个实参，则它实际上定义了为此类类型的隐式转换机制
        * 其他函数的形参如果是类类型的常量引用，则如果符合构造函数形参的类型，就会通过构造函数生成临时对象
    * 编译器只自动进行一次类类型转换
    * **抑制**构造函数定义的隐式类型转换
        * 将函数声明为`explicit`
        * 只对一个参数的构造函数有效，因为多个参数的构造函数不能执行隐式转换
* 聚合类
    * 定义
        * 所有成员都是public的
        * 没有定义任何构造函数
        * 没有类内初始值
        * 没有基类，没有virtual函数
    * 可以用一个成员初始化列表初始化聚合类的数据成员
* 字面值常量类

#### 类的静态成员
* 与类本身直接相关，而不是与类的各个对象保持关联
* 实现
    * 声明
        * 声明前加上`static`
        * 在类内声明
    * 定义
        * 在类外定义，不可以重复`static`
        * 在类内定义
            * 静态成员在类内定义必须是**字面值常量类型**
            * `static constexpr`
* 使用
    * 通过类，使用作用域运算符
    * 通过对象，虽然静态成员不属于某个对象，但每个对象都可以使用
    * 成员函数不通过运算符可以直接访问
* 静态成员适用场景
    * 静态成员可以是不完全类型（类内声明此类的静态**类**类型），而非静态成员只能声明它所属类的指针或者引用
    * 可以使用静态成员作为默认实参
* 不包含`this`指针

