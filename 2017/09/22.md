## C++ 表达式

* 左值/右值
    * C++的表达式，只有左值右值两种
    * 当一个对象被用作右值，用的是对象的值（内容）
    * 当一个对象被用作左值，用的是对象的身份（内存中的位置）
    * 对于`decltype`，如果表达式是左值，`decltype`作用该表达式（**不是变量**）将得到一个引用类型
    ```C++
    int *p, i;
    decltype (*p) x;    //解引用会生成左值，所以这里相当于 int &x;
    decltype (i) y;     //虽然i是左值，但是i是变量，这里相当于 int y;
    decltype (&p) z;    //取地址生成右值，这里相当于 int **z;
    decltype (&i) w;    //相当于 int *w;
    ```

#### 算数运算符
* `+(一元正号) -(一元负号) * / % +(加法) -(减法)`
* 注意数据溢出
    * 有符号的溢出直接溢出到符号位

#### 逻辑和关系运算符
* `! < <= > >= == != && ||`
* 运算对象和求值结果都是右值

#### 赋值运算符
* 赋值运算符左侧必须是可修改的左值
* 右结合律
    * 从右向左结合，而且返回的结果是左侧运算对象，所以可以多重赋值

#### 递增/递减运算符
* 前置版本将对象本身作为左值返回
* 后置版本将对象的原始值的副本作为右值返回
* 除非必须，不适用后置版本
    * 后置版本需要将原始值存储下来，资源浪费
* 后置版本的妙用
```C++
auto p = v.begin();
while (p! = v.end() && *p >= 0) // 输出到第一个负值之前 
    cout << *p++ << endl;       // ++ 优先级大于 *，这里等于 cout << *p <<endl; p++;
```

#### 成员访问运算符
* `. ->`
* `ptr->men`等价于`(*ptr).mem`

#### 条件运算符
* ` ? : `
* 条件运算符的两个表达式都是左值时结果才是左值
* 表达式左值/右值都可以，所以可嵌套
* 右结合律

#### 位运算符
* `~ << >> & ^ |`
* 对有符号位的类型处理方式未定义
* `<< >>`
    * 作为位移运算符
        * 移出边界之外的值直接丢弃
    * 作为重载的IO运算符
        * 左结合律
        * 返回值为输入输出流，所以可以多重输入输出

#### sizeof运算符
* 对于无效指针也可以正确返回指针所指类型的字节数，在sizeof中解引用无效指针是安全的

#### 逗号运算符
* 先对逗号运算符左侧表达式求值，然后丢弃结果，真正返回的结果是右侧表达式的值

#### 类型转换
* 隐式转换
    * 算数转换
        * 整型提升
        * 小类型对象转化为大类型对象
    * 数组转换指针
    * 指针的转换 
        * void*
        * ...
    * 布尔型转换
        * if (exp)
        * ...
    * 常量转换
        * int i; const int &j = i;
        * ... 
    * 类类型转换
        * string s = "this a char array"  
* 显式转换
    * `static_cast`
        * 除底层const外都可以使用
    * `const_cast`
        * 只能改变底层const
    * `reinterpret_cast`
        * 对运算对象的位模式提供低层次的重新解释
        * **极其危险**
    * 旧版的显示转换
        * `type (expr)`
        * `(type) expr`
        * 因为转换用途不明显，也比较危险