## 左值引用/右值引用

* 右值引用的是右值，也就是资源（对象）值，而非对象本身
* 右值本身时即将要销毁的值，可以用右值引用来**接管资源**
* 将右值引用赋值给**左值**，就是接管**右值引用接管的资源**

#### 左值持久/右值短暂
* 左值有持久的状态
* 右值要么是字面常量，要么是表达式求值过程中创建的临时对象
    * 所有引用的对象将要被销毁
    * **该对象没有其他用户**
* 使用右值引用可以自由接管所引用的对象的**资源**

#### 变量是左值
* 变量名是存储地址的**名称**，编译后为对应的**地址**
* 有名字的一定是左值
    * 右值引用的名字（变量名）也是左值
    * 因此不能把右值引用**直接绑定**到一个变量上，这个变量是右值引用类型也不可以

#### std::move
* 解决右值引用绑定到左值的问题
* `std::move()`可以获得绑定到**左值**上的**右值**引用
* 本质上是对`static_cast<T &&>`的封装
    * 所以使用`std::move()`也就明确表示了放弃对此左值的资源的所有权，也就是不再对左值中的资源值进行任何假设

#### 移动构造函数/移动赋值运算符
* noexcept
    * 保证在移动构造不会抛出异常，并且需要先调用移动构造的情况下，需要声明`noexcept`
    * 编译器为了防止**移动构造**的过程抛出异常，导致**旧内存空间**数据缺失而且**新内存空间**数据不完整的情况，会优先调用**拷贝构造**，因为拷贝构造的过程即使抛出异常，**旧内存空间**也是完整存在的
        * `vector`这样的标准库就可以保证不会在`push_back`时发生异常的情况下自身数据丢失，所以调用的时候会优先调用**移动构造**
* **移动左值，拷贝右值**
    * 没有移动构造，右值也会被拷贝
* 成员函数的右值引用形参
    * 与普通引用构成重载
```c++
void push_back(const T&);   // 拷贝：绑定到任意类型的X
void push_back(T&&);        // 移动：只能绑定到类型X的可修改的右值
```