## C++ 模板

* 模板是泛型的基础

#### 函数模板
* 编译器通过**函数实参**推断**模板实参**
* 用`typename`和`class`声明模板参数没有区别
* 非类型模板参数
    * 表示**值**而非**类型**
    * 实参必须是常量表达式
* 编译器在模板定义时不生产代码，只有在实例化出模板的一个特定版本时才会生成代码

#### 类模板
* 编译器不能为**类模板**推断**模板参数**类型
     * 显式指定模板实参列表
* 类模板成员函数
    * 定义在类模板**内**的成员数被隐式声明为`inline`
        * 在类模板的作用域中，可以直接使用模板名，不提供实参
    * 定义在类模板**外**的成员函数需要显式声明和类模板相同的**模板参数**
        * `template <typename T> ret-type TemplateClass<T>::member_name(parm-list)`
* 类模板和友元
    * 一对一友好关系
        * `friend`声明与模板类相同的模板参数名，不需`template <typename>`
    * 通用友好关系
        * `friend`声明与类不相同的模板参数名（没有就算了），需要`template <typename>`
    * 特定友好关系
        * `friend`声明一个特定的实例
* 模板类型别名
    * `typedef`无法实现，只能通过`using`
* 类模板的static
    * 每个类模板的实例都有独有一个`static`对象

#### 模板参数
* 作用域
    * 隐藏外层作用域
* 作用域运算符的二义性
    1. 访问类中的`static`数据成员    
    2. 访问类中的类型成员
    * 默认情况下，通过作用域运算符访问的不是类型
        * 使用模板类型参数的**类型成员**时，需要用`typename`显式指定
* 默认模板实参

#### 成员模板
* 本身是模板的成员函数
    * 非模板类的成员模板
    * 类模板的成员模板

#### 控制实例化
* 避免多个文件中**相同实例**的模板的额外开销
* `extern template` 实例化声明
* `template` 实例化定义
