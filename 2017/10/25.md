## C++ OOP

* 数据抽象
    * 实现类的接口是实现分离
* 继承
    * 定义相似的类型，并对其相似关系建模
* 动态绑定
    * 一定程度上忽略相似类型的区别，以统一的方式调用

#### 继承
* 成员函数的继承
    1. 虚函数
        * `virtual`
        * 派生类中的虚函数覆盖基类中的虚函数
    2. 普通函数
        * 在派生类中不存在对基类函数进行覆盖的函数，无论基类是否声明`virtual`
* 派生类对象及派生类向基类的类型转换
    * 派生类的概念模型中包括基类的成员，因此可以用**基类的指针或引用**绑定到**派生类的基类部分**上

#### 基类/派生类的类型转换
* 静态类型
    * **编译时**得出
    * 变量声明或表达式生成的类型
* 动态类型
    * **运行时**得出
    * 变量或表达式表示的内存中的对象的类型
* 类型转换
    * 从派生类向基类的类型转换只对指针和引用有效（对象无效）
    * 基类不存在向派生类的类型转换
    * 访问限制
        * 只有`public`继承才能使用派生类向基类的转换

#### 虚函数
* 使用**基类**指针或引用调用**虚成员函数**实现动态绑定
* 覆盖基类的函数时，形参、返回类型类型必须一致
* `final`和`override`
    * final
        * 表示此函数**不能**作为被覆盖的基类**虚函数**
    * override
        * 强制编译器检测**派生类**的函数是否覆盖的**基类**函数
* 回避虚函数
    * 对虚函数的调用不执行动态绑定
    * 使用作用域运算符强制执行特定版本

#### 抽象基类
* 抽象出接口，不提供实现
* 含有**纯虚函数**的类就是抽象基类
* 不能直接创建一个抽象基类的对象
* `=0`

#### 访问控制
* 派生类对基类成员的访问权限受两个因素影响
    1. 基类中**该成员**的访问说明符
        * 控制派生类**成员**及**友元**的访问权限
    2. 派生类的**派生类列表**中的访问说明符
        * 控制派生类**用户**（对象或派生类）的访问权限
        * 控制派生类的**派生类**的访问权限
* 类的设计
    * 类的三种用户
        * 普通用户
            * 使用类的对象，访问类的公共接口
        * 类的实现者
            * 编写类成员和友元，类的公共接口和私有实现都有权限访问
        * 派生类
            * 需要基类声明`protected`，派生类及其友元能使用部分接口（不包括私有部分）
* 友元
    * 不能传递
    * 不能继承
* 改变派生类继承自基类的成员的访问级别
    * `using`声明

#### 继承中的作用域
* 对象、引用或指针的**静态类型**决定对象的哪些**成员**可见
    * 即使静态类型与动态类型不一致
    * 从**静态类型**的作用域开始向上级作用域中搜索**成员**
* 声明在**内层作用域**的函数不会重载声明在**外层作用域**的函数，而是隐藏外层作用域的函数
* 定义在**派生类**中的函数也不会重载其**基类**中的函数，而是隐藏基类的函数（即使形参列表不一致）
