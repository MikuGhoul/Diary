## C++ 模板
* part2

#### 模板实参推断
* 类型转换
    * 模板实参只支持两种转换
        1. const转换
            * 非const转const
        2. 数组或函数指针转换
            * 转指针
    * 不支持的转换
        * 算术转换、派生类向基类转换、自定义转换
    * 模板类的**非模板参数**转换规则正常

* 函数模板显式实参
    * 像类模板一样写在`<typanme >`中
    * **显式模板实参**由左至右顺序对应**模板参数**匹配

* 尾置返回类型
    * 可由之前的模板参数类型推断出的类型，可以用尾置返回类型简化

* 引用折叠
    * 不能直接定义**引用**的**引用**
    * 但可以通过**类型别名**或**模板类型参数**间接定义
    * 引用的引用形成**折叠**
        * 折叠成`X&`的类型
            * `X& &`
            * `X& &&`
            * `X&& &`
        * 折叠成`X&&`的类型
            * `X&& &&`
    * 可以传递给模板参数的**右值引用**任意类型
        * * 模板参数的右值引用可以绑定到左值(`X& &&`)
    
* `std::move`原理
    ```C++
    template<typename T>
    typename remove_reference<T>::type&& move(T&& t)
    {
        return static_cast<typename remove_reference<T>::type&&>(t);
    }
    ```

* 转发
    * `std::forward`
        * 保持类型信息
        * 通过显式**模板实参**调用

#### 重载和模板
* **非模板函数**或**最特例化**版本优先调用

#### 可变参数模板
* 未知实参的数目和类型
* 参数包
    * `typename...`
    * `sizeof...`

#### 模板特例化
* 为原模板中的每个模板参数都提供实参