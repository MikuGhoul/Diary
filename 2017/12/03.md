## Principles of Operating Systems
* part 3

### 物理内存管理：连续内存分配

#### 计算机体系结构/内存层次
* 内存层次，速度高到低
    1. 寄存器
    2. 高速缓存
        * L1缓存
        * L2缓存
    3. 内存
    4. 硬盘
    5. 其他存储
* 程序不能**显式**使用缓存，由硬件控制
* 缓存未命中，去内存找
* 内存由操作系统控制
* 内存中没有再去外存找
* 操作系统的内存管理
    * 物理地址空间
        * 内存
            * 以字节（byte）为基本单位，每字节8bit
        * 外存
            * 以扇区为基本单位，每扇区512byte
    * 逻辑（虚拟）地址空间
        * 进程
        * 内核
    * 在物理地址空间上，通过**存储管理单元**（MMU）构建一层逻辑地址空间
        * 抽象
            * 将**线性的物理地址空间**转变成**抽象的逻辑空间**
        * 保护
            * 独立地址空间。每个进程只能访问自己的空间，虽然在物理地址上可能相邻
        * 共享
            * 访问相同的内存。比如操作系统内核代码，每个进程复制一份会很低效
        * 虚拟化
            * 更大的地址空间。逻辑地址空间里存数据的地址空间可以大于物理内存的总量
* 操作系统的内存管理方式
    * 重定位
    * 分段
    * 分页
    * 虚拟存储

#### 地址空间 & 地址生成
* 逻辑地址生成
    1. 高级语言源程序
    ``` c++
    foo();
    ```
    2. 编译为汇编程序
    ```	armasm
    push ...
    inc SP, x
    jmp _foo
    ```
    3. 汇编的编译器
    ```	armasm
    ; 地址0
    ...
    push ...
    inc SP, 4   ; 符号替换为对应地址
    jmp 75      
    ...
    ; 地址75
    ```
    4. 链接（把函数库加载进来）
    ```	armasm
    ; 地址0
    ; 函数库
    ; 地址100
    ...
    jmp 175     ; 加载函数库后地址偏移
    ...
    ; 地址175
    ```
    5. 程序加载（重定位）
    ```	armasm
    ; 地址 1000
    ; 函数库
    ; 地址 1100
    ...
    jmp 1175    ; 重定位，映射为真正的物理地址
    ...
    ; 地址 1175
    ```
* 地址生成时机和限制
    * 编译时
        * 假设起始地址已知，程序的地址是写死的
        * 如果起始地址改变，必须重新编译
    * 加载时
        * 编译器生成可重定位的代码
        * 加载时，生成绝对地址
    * 执行时
        * 使用相对地址，出现在使用虚拟存储的系统中
        * 执行时代码可以移动
        * 需地址转换、映射硬件支持
* 地址检查
    * 进程经cpu产生逻辑地址
    * 如果逻辑地址的**偏移量**大于**段长度**寄存器的值
        * 内存异常
    * 否则合法访问
    * 偏移量加上**段基质寄存器的值**得到物理地址

#### 连续内存分配
* 内存碎片
    * 外部碎片
        * 分配**单元之间**的未被使用的内存
        * 过小的空闲块，其他进程要申请的所有内存都大于此空闲块
    * 内部碎片
        * 分配**单元内部**的未被使用的内存
        * 进程需要的内存空间不是2的整数次幂
* 动态分区分配策略
    * 最先匹配
        * 原理 & 实现
            * 空闲分区列表按**地址顺序排序**
            * 分配过程时，搜索第一个适合的分区
            * 释放分区时，检查是否可与临近的空闲分区合并
        * 优点
            * 简单
            * 在高地址空间有大块的空闲分区
        * 缺点
            * 外部碎片
            * 分配大块时较慢
    * 最佳匹配
        * 原理 & 实现
            * 空闲分区列表按照**大小排序**
            * 分配时，查找一个**适合**的分区
                * 比需要的空间大的空闲的分区，而且大的最**少**
            * 释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序
        * 优点
            * 大部分分配的尺寸较小时，效果好
                * 可避免大的空闲分区被拆分
                * 可减少外部碎片的大小
        * 缺点
            * 外部碎片
            * 释放分区较慢
            * 容易产生很多无用内部小碎片
    * 最差匹配
        * 原理 & 实现
            * 空闲分区列表按照大小排序
            * 分配时，选最大的分区
                * 比需要的空间大的空闲的分区，而且大的最**多**
            * 释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序
        * 优点
            * 中等大小的分配较多时，效果最好
            * 避免出现太多的小碎片
        * 缺点
            * 释放分区较慢
            * 外部碎片
            * 容易破坏大的空闲分区，因此后续难以分配大的分区
* 碎片整理/紧凑
    * 整理：调整进程占用的分区位置来减少分区碎片
    * 紧凑：**移动**分配给进程的内存分区，合并外部碎片
        * 条件
            * 所有的应用程序可以**动态重定位**
        * 等待状态下移动
    * 对换：**抢占**等待状态下的进程的分区，将其数据放在外存
        * linux的swap分区：通过碎片对换，扩展内存

### 物理内存管理：非连续内存分配
* 连续内存分配缺点
    * 分配给程序的物理内存必须连续
    * 存在外碎片和内碎片
    * 内存分配的动态修改困难
    * 内存利用率较低
* 非连续内存分配设计目标
    * 允许一个程序的使用非连续的物理地址空间
    * 运行共享代码与数据
    * 支持动态加载和动态链接
* 非连续分配需要解决的问题
    * 实现虚拟地址和物理地址的转换
        * 软件实现
            * 灵活，开销大
        * 硬件实现
            * 够用，开销小
    * 如何选择非连续分配中的内存分块大小
        * 段式存储
        * 页式存储

#### 段式存储
* 进程的**逻辑地址空间**由多个段组成
    * 主代码段
    * 子模块代码段
    * 公用库代码段
    * 堆栈段
    * 堆数据
    * 初始化数据段
    * 符号表
    * ...
* 段概念
    * 每段对应一个连续的内存块
    * 若干个段组成进程逻辑地址空间
* 段访问：逻辑地址由二元组(s, addr)表示
    * 段号——s
    * 段内偏移——addr
    * 过程
        * 由段号查进程的**段表**
            * 段表包括基质和段长度（都是物理地址）
        * 地址检查
        * MMU
            * 物理地址 = 基质 + 偏移
#### 页式存储
* 页帧
    * **物理地址**空间划分的基本分配单位
    * 大小2^n
* 页面
    * **逻辑地址**空间划分的基本分配单位
    * 页面和页帧大小必须相同
* 页面到页帧转换
    * 逻辑地址到物理地址的转换
    * **页表**
    * MMU/TLB

#### 页表
* 逻辑**页号**到物理**帧号**的转换
* 页表结构
    * 每个页面对应一个**页表项**
        * 页表项包含帧号，**页表项标志**
            * 页表项标志包含存在位，修改位，引用位...
    * 随进程运行状态二动态变化
    * 页表基质寄存器
        * 页表起始位置
* 快表（TLB）
    * 利用缓存机制，减少对内存的访问
    * 把近期访问的页表项缓存在cpu中
    * 如果TLB命中，物理页号会很快被获取
    * 如果TLB未命中，对应表项更新到TLB
* 多级页表
    * 间接引用，减少页表的长度
* 反置页表
#### 段页式存储
* 通过指向相同的页表基质，实现进程间的段共享