## Principles of Operating Systems
* part 4

### 虚拟存储
#### 覆盖 & 交换
* 覆盖
    * 目标
        * 在较小的内存中运行较大的程序
    * 方法
        * 根据程序逻辑结构，将程序划分为若干**功能相对独立**的模块，将不会同时执行的模块**共享**同一块内存
            * 必要部分（常用功能）的代码和数据常驻内存
            * 可选部分（不常用部分）放在其他程序模块中，只在需要时装入内存
            * 不存在调用关系的模块可相互覆盖，共用同一块内存区
* 交换
    * 目标
        * 增加正在运行或需要运行的程序的内存
    * 方法
        * 将暂时不运行的程序放到外存
            * 换入换出的基本单位式**整个进程**的地址空间
* 比较
    * 覆盖
        * 发生在进程的内部模块间
        * 需要掌握进程的内部模块逻辑结构
        * 开销小，但是编写出内部逻辑结构较难
    * 交换
        * 发生在进程间
        * 开销大，但是编写容易

#### 局部性原理
* 程序在执行过程中的一共较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域
    * 时间局部性
        * 一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内
    * 空间局部性
        * 当前指令和邻近的几条指令，当前访问的数据和临近的几个数据都集中在一个较小区域内
    * 分支局部性
        * [一条跳转指令的两次执行，很可能跳到相同的内存位置](https://stackoverflow.com/a/11227902/8013228)
``` C++
// 页面大小4K，每个进程1页。int[1024][1024]二维数组按行存储，每一行放在一个页面中。

// 1024 * 1024 次缺页中断
for (j = 0; j < 1024; ++j)
    for (i = 0; i < 1024; ++i)
        A[i][j] = 0;
// 1024 次缺页中断
for (i = 0; i < 1024; ++i)
    for (j = 0; j < 1024; ++j)
        A[i][j] = 0;
```

#### 虚拟存储
* 思路
    * 将不常用的部分内存块暂存到外存
* 原理
    * 装载程序时 
        * 只将当前指令执行需要的部分页面或段装入内存
    * 指令执行中需要的指令或数据不在内存（称为**缺页/缺段**）时
        * 处理器通知操作系统将相应的页面/段调入内存
    * 操作系统将内存中暂时不用的页面或段保存到外存
* 实现
    * 虚拟页式存储
    * 虚拟段式存储

#### 虚拟页式存储
* 在页式存储管理的基础上，增加请求调页和页面置换
* 思路
    1. 当用户程序要装载到内存运行时，只装入**部分页面**，就启动程序运行
        * 页式存储会加载所有页面到内存中
    2. 进程在运行中，发现有需要的代码或数据不在内存中时，则向系统发出**缺页异常**
        * **逻辑页面**通过**页表**找对应的**物理页帧**，在页表中找不到对应的页表项时产生缺页异常
    3. 操作系统处理缺页异常，将外存中相应的页面调入内存，使进程继续运行
* 页表标志位结构
    * 驻留位
        * 表示该页是否在内存中
    * 修改位
        * 回收该物理页面时，据此判断是否要把它的内容写回外存
            * 在内存中修改过，放回外存要**修改**外存
            * 在内存中没有修改过，**直接作废**此页
    * 访问位
        * 该页面是否被访问过
            * 用于**页面置换算法**
    * 保护位
        * 该页的允许访问方式

### 页面置换算法

#### 概念
* 功能
    * 当出现缺页异常，需要调入新页面，而**内存已满**时，置换算法选择被**置换到外存的物理页面**
* 设计目标
    * 尽可能减少页面的调入调出次数
    * 把未来不再访问或短期内不访问的页面调出
* 页面锁定
    * 针对必须**常驻内存**的逻辑页面
        * 操作系统的关键部分
        * 要求响应速度的代码和数据
    * 实现
        * 页表中的**锁定标志位**
* 分类
    * 局部页面置换算法
        * 置换页面的选择范围仅限于**当前进程**占用的物理页面
        * 思路
            * 最优算法（OPT）
            * 先进先出算法（FIFO）
            * 最近最久未使用算法（LRU）
        * 实现
            * 时钟算法（Clock）
            * 最不常用算法（LFU）
    * 全局页面置换算法
        * 置换页面的选择范围是**所有**可换出的物理页面
        * 实现
            * 工作集算法
            * 缺页率算法

#### 最优算法/先进先出算法/最近最久未使用算法
* 最优算法
    * 置换在**未来最长时间不会被访问**的页面进行置换
    * 实现
        * 缺页时，计算内存中每个逻辑页面的**下一次**访问时间
        * 选择未来最长时间不访问的页面
    * 特征
        * 缺页最少，是理想情况
        * 实际系统中**无法实现**
            * 无法预知页面的下次访问前的等待时间
    * 作为其他算法的性能**评测依据**
* 先进先出算法
    * 选择**在内存驻留时间最长**的页面进行置换
    * 实现
        * 维护一个记录所有位于内存中的逻辑**页面链表**
        * 链表元素按**驻留在内存中的时间顺序**，链首最长，链尾最短
        * 缺页时，选择链首页面进行置换，新页面加到链尾
    * 特征
        * 实现较简单
        * 性能较差，调出的页面**可能**是经常访问的
        * 进程分配物理页面增加时，缺页并不一定减少
            * Belady
        * 很少单独使用
* 最近最久未使用算法
    * 选择**过去最长时间没有被引用**的页面进行置换
    * 依据
        * 如某些页面**过去**长时间未被访问，则**未来**也可能长时间不会访问
    * 思路
        * 缺页时，计算内存中每个逻辑页面的**上一次**访问时间
        * 选择上一次使用当当前时间**最长**的页面
    * 特征
        * 复杂度高，开销大
        * 最优算法的近似
    * 可能的实现方法
        * 维护一个按最近一次访问时间排序的**页面链表**
            * 链首是最近使用的页面
            * 链尾是最久未被使用的页面
            * 访问内存时，找到相应页面，并移到链首
            * 缺页时，置换链尾页面
        * 活动页面栈
            * 访问页面时，将此页号压入栈顶，把栈内相同的页号抽出
            * 缺页时，置换栈底页面

#### 时钟置换算法/最不常用置换算法
* 时钟置换算法
    * 思路
        * 仅对页面的**访问情况**进行大致统计
    * 数据结构
        * 页表项增加**访问位**，描述页面过去一段时间的访问情况
        * 各页面组织成**环形链表**
        * **指针**指向最先调入的页面
    * 算法
        * 访问页面时，在页表项记录页面访问情况
        * 缺页时，从指针处开始顺序查找未被访问的页面进行置换
    * 实现
        * 页面装入内存时，访问位初始化为0
        * 访问页面时，访问位置1
        * 缺页时，从指针处顺序检查环形链表
            * 访问位为0，则置换该页
            * 访问位为1，则访问位置0，指针移到下一页面...
    * 特征
        * 时钟置换算法是LRU和FIFO的折中
* 改进的时钟置换算法
    * 思路
        * 减少**修改页**的缺页处理开销
    * 实现
        * 在页面中增加**修改位**，在访问时进行修改
        * 缺页时，修改页面标志位，以跳过有修改的页面
            * 访问位置0并且修改位置0时置换
* 最不常用置换算法
    * 思路
        * 缺页时，置换**访问次数**最少的页面
    * 实现
        * 每个页面设置一个访问计数
        * 访问页面时，访问计数加1
        * 缺页时，置换计数最小的页面
    * 和LRU的区别
        * LRU关注**多久未访问**，时间越短越好
        * LFU关注**访问次数**，次数越多多好

#### 局部置换算法特征
* Belady现象
    * 现象
        * 采用FIFO等算法时，可能出现分配的**物理页面数**增加，**缺页次数**反而升高的异常现象
    * 原因
        * FIFO算法的**置换特征**与进程访问内存的**动态特征**矛盾
        * 被FIFO置换出去的页面并不一定时进程近期不会访问的页面
    * LRU置换算法没有Belady现象
* LRU & FIFO & Clock比较
    * LRU算法和FIFO本质上都是**先进先出**的思路
        * LRU依据页面的**最近访问时间**排序
        * LRU需要动态调整顺序
        * FIFO依据页面**进入内存的时间**排序
        * FIFO的页面进入时间是固定不变的
    * LRU可退化成FIFO
        * 页面进入内存后没有访问，最近访问时间与进入内存的时间相同
    * **LRU算法性能好，但系统开销大**
    * **FIFO算法系统开销小，但有Belady现象**
    * **Clock算法是折中**
        * 页面访问时，不动态调整页面在链表中的顺序，仅作标记
        * 缺页时，再把它移动带链表末尾
    * 对于未被访问的页面，Clock算法和LRU表现一样（此时LRU退化为FIFO）
    * 对于访问过的页面，Clock算法不能记录准确的访问顺序，而LRU可以

#### 工作集置换算法
* **全局置换算法**为进程分配**可变数目**的物理页面
* 工作集
    * 一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t, △)
        * t是当前执行时刻
        * △称为工作集窗口。表示一个定长的页面访问时间窗口
        * W(t, △)表示当前时刻t前的△时间窗口中的所有访问页面所组成的集合
        * |W(t, △)|指工作集大小，即页面数目
* 常驻集
    * 当前时刻，进程实际驻留在**内存**中的页面集合
* 缺页率与常驻集的关系
    * 常驻集⊇工作集，缺页较少
    * 工作集发生剧烈变动时，缺页较多
        * 比如进程执行的功能，模块有切换
    * 进程常驻集大小达到一定数目后，缺页率也不会明显下降
* 工作集置换算法
    * 思路
        * 换出不在工作集中的页面
        * 并不是像局部置换一样，**缺页的时候做置换**
    * 窗口大小τ
        * 当前时刻**前τ个内存访问的页**引用是**工作集**，τ被称为窗口大小
    * 实现方法
        * 访存链表
            * 维护窗口内的访问页面链表
        * 访存时，换出不在工作集的页面，更新访存链表
        * 缺页时，换入页面，更新访存链表
#### 缺页率置换算法
* 缺页率
    * 缺页率 = 缺页次数 / 内存访问次数
    * **缺页率 = 缺页平均时间间隔的倒数**
* 影响缺页率的因素
    * **页面置换算法**
    * 分配给进程的物理页面数目
    * 页面大小
    * 程序的编写方法
* 通过调节常驻集大小，使每个进程的缺页率保持合理范围（**缺页率与进程的物理页面数成反比**）
    * **若进程缺页率过高，则增加常驻集以分配更多的物理页面**
        * 进程的物理页面过少，会导致缺页率过高
    * **若进程缺页率过低，则减少常驻集以减少物理页面**
        * 进程物理页面增多后，缺页率下降。但此时并发度降低，cpu效率下降
* 实现
    * 访存时，设置引用位标志
    * 缺页时，计算上次缺页时间`t_last`到现在`t_current`的时间间隔
        * 如果`t_current - t_last <= T`，则增加缺失页到常驻集中
            * 缺页率高
        * 如果`t_current - t_last > T`，则置换所有在`[t_last, t_current]`时间内没有被引用的页
            * 缺页率低

#### 抖动 & 负载控制
* 抖动
    * 进程物理页面太少，不能包含工作集
    * 造成大量缺页，频繁置换
    * 进程运行速度变慢
* 产生抖动的原因
    * 驻留内存的进程数目增加，分配给每个进程的物理页面数减小，缺页率上升
* 操作系统需要在并发和缺页率之间达到一个平衡
    * 选择适当进程数目，和进程需要的物理页面数
        * 进程少，并发低
        * 进程多，没给进程的页面少，缺页率高
* 负载控制
    * 通过调节并发进程数来进行系统负载控制
        * ∑W = 内存的大小，此时并发进程数`N_max`
            * 工作集的总和等于内存大小时，并发进程时，cpu的利用率最高
        * 平均缺页间隔时间（MTBF）= 缺页异常处理时间（PFST），此时并发进程数`N_io_balance`
    * 负载均衡平衡点`N`
        * `N_max < N < N_io_balance`