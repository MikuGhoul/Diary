## Computer Networking A top-down approach
* part 3
* 运输层

#### 运输层概述
* 运输层为运行在不同主机上的应用进程之间提供了**逻辑通信**功能
    * 从应用程序角度看，不同进程的主机好像直接相连一样
    * **网络层**提供**主机之间**的逻辑通信，**运输层**提供**进程之间**的逻辑通信
* 运输层协议是在**端系统**中而不是在**路由器**中实现的
* 运输层协议
    * UDP
        * 用户数据报协议
        * 提供不可靠、无连接的服务
    * TCP
        * 传输控制协议
        * 提供可靠、面向连接的服务
* UDP与TCP最基本的功能
    * 将两个端系统间**IP的交付服务**扩展为运行在端系统上的**两个进程的交付服务**

#### 多路复用 & 多路分解
* 运输层的数据通过**套接字**交付给应用层的进程
* 多路分解
    * 将**运输层**报文段中的数据交付到正确的**套接字**
* 多路复用
    * 从**不同套接字**中收集数据块，并为每个数据块**封装首部信息**，从而生成报文段，再将报文段传递到网络层
* 每个套接字分配一个端口号，当报文段到达运输层时，运输层检查报文段中的**目的端口号**，**通过端口号定向到套接字**，以此来确定是目的主机的哪个进程来接收
* 无连接的套接字
    * UDP创建的套接字由二元组标识
        * (目的IP地址，目的端口号)
* 连接的套接字
    * TCP创建的套接字由四元组标识
        * (源IP地址，源端口号，目的IP地址，目的端口号)
#### UDP
* UDP在发送报文段之前，发送方和接收方的运输层实体之间**没有握手**（无连接）
* 相比TCP的优点
    * 没有TCP的拥塞机制
        * UDP整体时延小
    * 无需建立连接
        * DNS建立在UDP上，可以加快速度
    * 不需要维护连接状态
        * TCP为了提供可靠数据传输和拥塞控制，需要额外维护状态信息
    * 分组首部开销小
        * TCP 20字节，UDP 8字节
* UDP容忍数据丢失，但要求极小的发送速率
* UDP报文
    ```
    源端口号   |   目的端口号
    长度       |   校验和
    报文数据
    ```

#### 可靠数据传输原理
* 实现**可靠数据传输协议**的下层协议，比如网络层的IP协议，可能是**不可靠**的
* 构造可靠数据传输协议
    * 经完全可靠信道的可靠数据传输(rdt1.0)
        * 底层信道完全可靠
    * 经具有比特差错信道的可靠数据传输(rdt2.0)
        * 所有发送分组可能有些比特受损，但将**按其发送顺序被接收**
        * ARQ协议：自动重传协议
            * 差错检测
            * 接收方反馈
            * 重传
        * **停等协议**
            * 发送方在等待ACK/NAK时，不能获取上层数据
                * 发送方不会在确认接收方已经正确接收前（发送法收到ACK），发送新的数据块
    * 经具有比特差错的丢包信息的可靠数据传输(rdt3.0)
        * 除了比特受损外，还会丢包
        * 发送方选择一个时间值，超过此时长以判定为丢包
            * 实际的往返时延（RTT）无法准确预测，因此可能判断错误，导致冗余分组
            * 发送方每次发送一个分组都会启动一个**计时器**，在到期后中断发送方，**重传**数据
* 流水线可靠数据传输协议
    * rdt3.0由于停等协议有着非常低的发送方利用率
    * 不使用停等协议
        * 允许发送方发送多个分组
* GBN协议：回退N步
    * 允许发送方发送多个分组，但在流水线未确认的分组数不能超过某个N值
    * 序号分为四段
        * 已被确认段
        * 已发送，但未确认段
        * 可用，但还未发送段
        * 不可用段
* 选择重传
    * 解决GBN的性能问题
        * 单个分组的差错导致整个GBN分组重传
    * 按需重传
* 可靠数据传输机制总结
    * 校验和
        * 检测在一个传输分组中的比特错误
    * 定时器
        * 超时重传一个分组
        * 目的是解决ACK丢失，但若ACK时延过大，可能导致冗余
    * 序号
        * 为从发送方流向接收方的数据分组按顺序编号
        * 通过接收的分组序号空隙可以检测出丢失的分组
        * 通过具有相同序号的分组可以检测出冗余
    * 确认
        * ACK
        * 接收方用于告诉发送方一个分组或一组分组已经被正确接收到了
    * 否丢确认
        * NAK
        * 接收方用于高速发送方某个分组未被正确地接收
    * 窗口，流水线
        * 发送方被限制仅发送那些序号在一个指定范围内的分组
        * 通过一次发送多个分组但未被确认，发送方的利用率可在停等协议模式基础上增加

#### TCP
* TCP连接提供的是**双全工服务**
    * 在主机的进程A、B之间建立一条TCP连接，应用层数据可以在从进程B流向进程A的同时也从A流向B
* TCP报文
    ```
    源端口号   |   目的端口号
    序号
    确认号
    首部长度 | 保留未用 | URG | ACK | PSH | RST | SYN | FIN | 接收窗口
    因特网校验和  |   紧急数据指针
    选项
    数据
    ```
* 序号 & 确认号
    * 序号
        * 客户端的TCP对数据流中的数据进行**分块编号**，每一个号码被填入TCP报文段的首部**序号字段**中
    * 确认号
        * 客户端期望从服务端收到的下一个数据**分块序号**，被填入TCP报文的首部**确认字段**中
* TCP三次握手
    1. 客户端首先发送一个特殊的TCP报文段
        * **不包含应用层数据**
        * 报文段首部中的SYN标志位被置1
        * 随机选择一个初始序号client_isn，放在TCP SYN报文段的序号字段中，该报文段会被封装在一个IP数据报中，发送给服务器
    2. 服务端用另一个特殊的TCP报文段响应
        * TCP SYN报文段中的IP数据报到达服务器主机
        * 服务器从中取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量
        * 向客户端TCP发送允许连接的报文段(SYNACK报文段)
            * **不包含应用层数据**
            * SYN比特被置1
            * 确认号字段被置为client_isn + 1
            * 随机选择一个server_isn，放在TCP报文段的首部序号字段中
    3. 客户端再用第三个报文段作为响应
        * 收到SYNACK报文段，为该连接分配缓存和变量
        * 发送允许连接报文段的确认报文段
            * **包含应用层数据**
            * SYN比特被置0
            * 确认字段被置为server_isn + 1
    * 一旦握手成功，客户端就可以和服务器主机相互发送数据的报文段了，之后的每一个报文段中，SYN比特都将被置0
* 往返时间估计 & 超时
    * TCP采用超时/重传的机制处理报文段的丢失
    * 往返时间估计
        * 样本RTT: SampleRTT为从报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量
        * TCP不会为每个发送的报文测量SampleRTT，仅为已发送但目前尚未被确认的报文测量
            * 产生接近每个RTT的SampleRTT
        * 引入EstimatedRTT解决SampleRTT波动
            * `EstimatedRTT = (1 - x) * EstimatedRTT + x * SampleRTT`
            * [RFC 6298]中x为0.125
        * 引入DevRTT测量RTT的变化
            * `DevRTT = (1 - y) * DevRTT + y * | SampleRTT - EstimatedRTT |`
    * 超时
        * 超时时间
            * 应该大于等于EstimatedRTT，否则会不必要重传
            * 不能大于EstimatedRTT太多，否则报文丢失后，TCP不能短期内重传
        * `TimeoutInterval = EstimatedRTT + 4 * DevRTT`
* 可靠数据传输
    * TCP在IP不可靠的服务之上建立可靠数据服务
    * TCP的可靠数据服务可以确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流
        * **即该字节流与连接的另一端系统发出的字节流完全相同**
    * TCP发送方的3个与发送和重传的主要事件
        * 从上层应用程序接收数据
        * 定时器超时
        * 收到ACK
* 流量控制
    * TCP提供**流量控制服务**以消除发送方使接收方**缓冲溢出**的问题
    * 实现
        * 发送方维护一个称为**接收窗口**的变量，用于指示接收方还有多少可用的缓存空间
        * 因为TCP是全双工通信，所以在连接的两端各自维护一个接收窗口
* TCP连接管理
    * 进行连接
        * 三次握手
    * 终止连接
        * 参与一条TCP连接的两个进程中任何一个都能终止该资源
        * 过程
            * A端进程发出关闭连接命令
            * 引起A端TCP向服务器进程发送一个特殊的TCP报文段
                * 其首部中的标志位FIN比特被置为1
            * B端接收到该报文段
                * 向A回送确认报文段
            * A端对B端的终止报文段确认
            * 所有资源释放