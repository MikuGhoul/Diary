## Computer Networking A top-down approach
* part 3
* 运输层

#### 运输层概述
* 运输层为运行在不同主机上的应用进程之间提供了**逻辑通信**功能
    * 从应用程序角度看，不同进程的主机好像直接相连一样
    * **网络层**提供**主机之间**的逻辑通信，**运输层**提供**进程之间**的逻辑通信
* 运输层协议是在**端系统**中而不是在**路由器**中实现的
* 运输层协议
    * UDP
        * 用户数据报协议
        * 提供不可靠、无连接的服务
    * TCP
        * 传输控制协议
        * 提供可靠、面向连接的服务
* UDP与TCP最基本的功能
    * 将两个端系统间**IP的交付服务**扩展为运行在端系统上的**两个进程的交付服务**

#### 多路复用 & 多路分解
* 运输层的数据通过**套接字**交付给应用层的进程
* 多路分解
    * 将**运输层**报文段中的数据交付到正确的**套接字**
* 多路复用
    * 从**不同套接字**中收集数据块，并为每个数据块**封装首部信息**，从而生成报文段，再将报文段传递到网络层
* 每个套接字分配一个端口号，当报文段到达运输层时，运输层检查报文段中的**目的端口号**，**通过端口号定向到套接字**，以此来确定是目的主机的哪个进程来接收
* 无连接的套接字
    * UDP创建的套接字由二元组标识
        * (目的IP地址，目的端口号)
* 连接的套接字
    * TCP创建的套接字由四元组标识
        * (源IP地址，源端口号，目的IP地址，目的端口号)
#### UDP
* UDP在发送报文段之前，发送方和接收方的运输层实体之间**没有握手**（无连接）
* 相比TCP的优点
    * 没有TCP的拥塞机制
        * UDP整体时延小
    * 无需建立连接
        * DNS建立在UDP上，可以加快速度
    * 不需要维护连接状态
        * TCP为了提供可靠数据传输和拥塞控制，需要额外维护状态信息
    * 分组首部开销小
        * TCP 20字节，UDP 8字节
* UDP容忍数据丢失，但要求极小的发送速率
* UDP报文
    ```
    源端口号   |   目的端口号
    长度       |   校验和
    报文数据
    ```

#### 可靠数据传输原理
* 实现**可靠数据传输协议**的下层协议，比如网络层的IP协议，可能是**不可靠**的
* 构造可靠数据传输协议
    * 经完全可靠信道的可靠数据传输(rdt1.0)
        * 底层信道完全可靠
    * 经具有比特差错信道的可靠数据传输(rdt2.0)
        * 所有发送分组可能有些比特受损，但将**按其发送顺序被接收**
        * ARQ协议：自动重传协议
            * 差错检测
            * 接收方反馈
            * 重传
        * **停等协议**
            * 发送方在等待ACK/NAK时，不能获取上层数据
                * 发送方不会在确认接收方已经正确接收前（发送法收到ACK），发送新的数据块
    * 经具有比特差错的丢包信息的可靠数据传输(rdt3.0)
        * 除了比特受损外，还会丢包
        * 发送方选择一个时间值，超过此时长以判定为丢包
            * 实际的往返时延（RTT）无法准确预测，因此可能判断错误，导致冗余分组
            * 发送方每次发送一个分组都会启动一个**计时器**，在到期后中断发送方，**重传**数据
* 流水线可靠数据传输协议
    * rdt3.0由于停等协议有着非常低的发送方利用率
    * 不使用停等协议
        * 允许发送方发送多个分组
* GBN协议：回退N步
    * 允许发送方发送多个分组，但在流水线未确认的分组数不能超过某个N值
    * 序号分为四段
        * 已被确认段
        * 已发送，但未确认段
        * 可用，但还未发送段
        * 不可用段
* 选择重传
    * 解决GBN的性能问题
        * 单个分组的差错导致整个GBN分组重传
    * 按需重传
* 可靠数据传输机制总结
    * 校验和
        * 检测在一个传输分组中的比特错误
    * 定时器
        * 超时重传一个分组
        * 目的是解决ACK丢失，但若ACK时延过大，可能导致冗余
    * 序号
        * 为从发送方流向接收方的数据分组按顺序编号
        * 通过接收的分组序号空隙可以检测出丢失的分组
        * 通过具有相同序号的分组可以检测出冗余
    * 确认
        * ACK
        * 接收方用于告诉发送方一个分组或一组分组已经被正确接收到了
    * 否丢确认
        * NAK
        * 接收方用于高速发送方某个分组未被正确地接收
    * 窗口，流水线
        * 发送方被限制仅发送那些序号在一个指定范围内的分组
        * 通过一次发送多个分组但未被确认，发送方的利用率可在停等协议模式基础上增加

#### TCP
* TCP连接提供的是**双全工服务**
    * 在主机的进程A、B之间建立一条TCP连接，应用层数据可以在从进程B流向进程A的同时也从A流向B
* TCP三次握手
    1. 客户端首先发送一个特殊的TCP报文段
    2. 服务端用另一个特殊的TCP报文段响应
    3. 客户端再用第三个报文段作为响应
    * 前两个报文段不含有应用层数据，只有第三个报文段包含
* TCP报文
    ```
    源端口号   |   目的端口号
    序号
    确认号
    首部长度 | 保留未用 | URG | ACK | PSH | RST | SYN | FIN | 接收窗口
    因特网校验和  |   紧急数据指针
    选项
    数据
    ```
* 序号 & 确认号
    * 序号
        * 客户端的TCP对数据流中的数据进行**分块编号**，每一个号码被填入TCP报文段的首部**序号字段**中
    * 确认号
        * 客户端期望从服务端收到的下一个数据**分块序号**，被填入TCP报文的首部**确认字段**中
* 往返时间估计 & 超时
    * TCP采用超时/重传的机制处理报文段的丢失
    * 往返时间估计
        * 样本RTT: SampleRTT为从报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量
        * TCP不会为每个发送的报文测量SampleRTT，仅为已发送但目前尚未被确认的报文测量
            * 产生接近每个RTT的SampleRTT
        * 引入EstimatedRTT解决SampleRTT波动
            * `EstimatedRTT = (1 - x) * EstimatedRTT + x * SampleRTT`
            * [RFC 6298]中x为0.125
        * 引入DevRTT测量RTT的变化
            * `DevRTT = (1 - y) * DevRTT + y * | SampleRTT - EstimatedRTT |`
    * 超时
        * 超时时间
            * 应该大于等于EstimatedRTT，否则会不必要重传
            * 不能大于EstimatedRTT太多，否则报文丢失后，TCP不能短期内重传
        * `TimeoutInterval = EstimatedRTT + 4 * DevRTT`
* 可靠数据传输
    * TCP在IP不可靠的服务之上建立可靠数据服务
    * TCP的可靠数据服务可以确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流
        * **即该字节流与连接的另一端系统发出的字节流完全相同**
    * TCP发送方的3个与发送和重传的主要事件
        * 从上层应用程序接收数据
        * 定时器超时
        * 收到ACK
* 流量控制
    * TCP提供**流量控制服务**以消除发送方使接收方**缓冲溢出**的问题
    * 实现
        * 发送方维护一个称为**接收窗口**的变量，用于指示接收方还有多少可用的缓存空间
        * 因为TCP是全双工通信，所以在连接的两端各自维护一个接收窗口
* TCP连接管理
    * 