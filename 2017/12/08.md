## Principles of Operating Systems
* part 8

### 死锁 & 进程通信

#### 死锁
* 死锁的必要条件
    * 互斥
        * 任何时候只能有一个进程使用一个资源实例
    * 持有并等待
        * 进程保持至少一个资源，并正在等待获取其他进程持有的资源
    * 非抢占
        * 资源只能在进程使用后自愿放弃
    * 循环等待

#### 死锁的处理方法
* 死锁预防
    * 限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的**必要条件**
        * 互斥
            * 把**互斥**的共享资源封装成可同时访问
        * 持有并等待
            * 进程请求资源时，要求它不持有任何其他资源
            * 仅允许进程在开始执行时，一次请求所有需要的资源
        * 非抢占
            * 如进程请求不能立即分配的资源，则释放已占有资源
            * 只在能够同时获得所有需要资源时，才执行分配操作
        * 循环等待
            * 对资源排序，要求进程按顺序请求资源
* 死锁避免
    * 在使用前进行判断，只允许不会出现死锁的进程请求资源
        * 要求进程声明需要资源的**最大数目**
        * 限定提供与分配的资源数量，确保满足进程的最大需求
        * 动态检查资源分配状态，确保不会出现环形等待
    * 银行家算法
* 死锁检查并恢复
    * 在检测到运行系统进入死锁状态后，进行恢复

#### 银行家算法
* 数据结构
    * n
        * 线程数量
    * m
        * 资源类型数量
    * Max
        * 总需求量
        * n * m 矩阵
        * 线程Ti最多请求资源Rj的Max[i, j]个实例
    * Available
        * 剩余空闲量
        * 长度为m的向量
        * Rj类资源资源的数量为Available[j]
    * Allocation
        * 已分配量
        * n * m 矩阵
        * 线程Ti当前被分配了Allocation[i, j]个Rj类资源
    * Need
        * 未来需要量
        * n * m 矩阵
        * 线程Ti未来需要Need[i, j]个Rj类资源
    * Need[i, j] = Max[i, j] - Allocation[i, j]
* 安全判断算法
    1. Work & Finish 初始化
        * Work = Available
            * 当前资源剩余量
        * Finish[i] = false
            * 线程i没结束
    2. 寻找线程Ti
        * Finish[i] == false
        * Need[i] <= Work
        * 找到Ti转3，没找到转4
    3. 找到线程Ti，资源分配
        * Work = Work + Allocation[i]
        * Finish[i] = true;
        * 转2
    4. 如果所有线程Ti都满足Finish[i] == true，则系统处于安全状态。否则不安全
* 银行家算法
    1. 初始化
        * Requesti[j]为线程Ti的Rj类资源请求量
    2. 如果Requesti <= Need[i]，转3。否则拒绝申请，因为线程已经超过了其最大要求
    3. 如果Requesti <= Available，转4。否则Ti等待，因为资源不可用
    4. 通过安全判断算法来确定是否分配资源给Ti
        * 假设分配
        * 调用安全状态判断
            * 如果返回结果是安全，将资源分配给Ti
            * 如果返回结果是不安全，拒绝Ti的资源请求

#### 死锁检测
* 允许系统进入死锁状态
* 维护系统的资源分配图
* 定期调用死锁检测算法来搜索图中是否存在死锁
* 出现死锁时，用死锁恢复机制进行恢复

#### 进程通信（IPC）
* 通信机制
    * 信号，管道，消息队列，共享内存
* IPC提供两个基本操作
    * 发送操作
        * `send(message)`
    * 接收操作
        * `receive(message)`
* 直接通信
    * 进程必须正确命名对方
        * `send(P, message)`
            * 发送到进程P
        * `receive(Q, message)`
            * 从进程Q接收
    * 通信链路的属性
        * 自动建立链路
        * 一条链路恰好对应一对通信进程
        * 每对进程之间只有一个链接存在
        * 链接可以单向，也可以双向
* 间接通信
    * 通过操作系统维护的**消息队列**实现进程间的消息接受和发送
        * `send(A, message)`
            * 发送到消息队列A
        * `receive(A, message)`
            * 从消息队列A接收
        * 每个消息队列都有一个唯一的标识
        * 只有共享了相同的消息队列的进程，才能够通信
    * 通信链路属性
        * 只有共享了相同消息队列的进程，才建立连接
        * 连接可以是单向或双向
        * 每个消息队列可以与多个进程相关联
        * 每对进程可以共享多个消息队列
* 阻塞 & 非阻塞通信
    * 阻塞通信（同步）
        * 阻塞发送
            * 发送者在发送消息后**进入等待**，直到接收者成功收到才结束
        * 阻塞接收
            * 接收者在请求接收消息后**进入等待**，直到成功接收到才结束
    * 非阻塞通信（异步）
        * 非组赛发送
            * 发送者在消息发送后，可立即进行其他操作
        * 非阻塞接收
            * 没有消息发送时，接收者在请求接收消息后，接收不到任何消息
* 通信链路缓冲
    * 零容量
        * 发送方必须等待接收方
    * 有限容量
        * 通信链路缓冲队列满时，发送方必须等待
    * 无限容量
        * 发送方不需要等待

#### 信号 & 管道
* 信号(signal)
    * 进程间的软件中断通知和处理机制
    * 信号的接收处理
        * 捕获(catch)
            * 执行进程指定的信号处理函数被调用
        * 忽略(ignore)
            * 执行操作系统指定的缺省处理
        * 屏蔽(mask)
            * 禁止进程接收和处理信号
    * 传送的信息量小，只有一个信号类型
    * 响应速度快
* 管道(pipe)
    * 进程间基于内存文件的通信机制
        * 子进程从父进程继承文件描述符
        * 缺省文件描述符
            * `stdin`
            * `stdout`
            * `stderr`
    * 进程不关心管道的另一端
    * 管道相关的系统调用
        * 读管道
            * `read(fd, buffer, nbytes)`
            * `scanf()`是基于它实现的
        * 写管道
            * `write(fd, buffer, nbytes)`
            * `printf()`是基于它实现的
        * 创建管道
            * `pipe(rgfd)`
            * rgfd是两个文件描述符组成的数组
``` shell
$ ls | more
// 1. shell先建立管道
// 2. 建立ls进程
// 3. 将ls的标准输出(stdout)作为管道的写端
// 4. 建立more进程
// 5. 将more的标准输入(stdin)作为管道的读端
```

#### 消息队列 & 共享内存
* 消息队列
    * 由操作系统维护的以字节为基本单位的间接通信机制
* 共享内存
    * 把**同一个物理内存区域**同时映射到**多个进程的内存地址空间**的通信机制
    * 线程
        * 同一进程中的线程总是共享相同的内存地址空间
    * 进程
        * 每个进程都有私有内存地址空间
        * 每个进程的内存地址空间需明确设置共享内存段
    * 优点
        * 最快
        * 没有数据复制
    * 缺点
        * 不提供同步，必须用**额外的同步机制**来协调数据访问
    * 实现
        * 不同的逻辑地址的页表项映射到相同的物理内存地址