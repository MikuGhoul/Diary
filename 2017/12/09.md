## Principles of Operating Systems
* part 9

### 文件系统
* 分配文件磁盘空间
    * 管理文件块
        * 位置和顺序
    * 管理空闲空间
        * 位置
    * 分配算法
        * 策略
* 管理文件集合
    * 定位
        * 文件及其内容
    * 命名
        * 通过名字找到文件
    * 文件系统结构
        * 文件组织方式
* 数据可靠和安全
    * 安全
        * 多层次保护数据安全
    * 可靠
        * 持久保存文件
        * 避免系统崩溃、攻击等
* 文件属性
    * 名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间...

#### 文件描述符
* 文件访问模式
    * 进程访问文件数据前必须先打开文件
    ``` c++
    f = open(name, flag);
    ...
    read(f, ...);
    ...
    close(f);
    ```
* 内核跟踪进程打开的所有文件
    * 操作系统为每个进程维护一个**打开文件表**
    * 文件描述符是打开文件的标识
* 文件表述符是操作系统在**打开文件表**中维护的打开文件的**状态和信息**
    * 文件指针
        * 最后一次读写的位置
        * 每个进程分别维护自己的打开文件指针
    * 文件打开计数
        * 当前打开文件的次数
        * 最后一个进程关闭文件时，将其从打开文件表中移除
    * 文件的磁盘位置
        * 缓存数据访问信息
    * 访问权限
        * 每个进程的文件访问模式信息
* 文件的视图
    * 文件的用户视图
        * 持久的数据结构
    * 文件的系统接口
        * 字节序列的集合
    * 文件的系统视图
        * 数据块的集合
        * 数据块是逻辑存储单元，而扇区是物理存储单元
        * 块大小 != 扇区大小
* 视图转换
    * 进程读文件
        * 获取字节所在的数据块
        * 返回数据块中的对应部分
    * 进程写文件
        * 获取数据块
        * 修改数据块中对应部分
        * 写回数据块
    * 文件系统的**基本操作单位是数据块**
        * `getc() & putc()`即使每次只访问1byte的数据也需要读写4k的数据
* 访问模式
    * 顺序访问
        * 按字节依次读取
        * 大多数的文件访问都是顺序访问
    * 随机访问
        * 从中间读写
        * 不常用
        * 虚拟内存把内存页存储在文件
    * 索引访问
        * 依据数据特征索引
        * 通常操作系统不提供完整的索引访问
        * 数据库是建立在索引内容的磁盘访问上
* 文件内部结构
    * 无结构
        * 单词、字节序列
    * 简单记录结构
        * 分列
        * 固定长度
        * 可变长度
    * 复杂结构
        * 格式化的文档(Word, PDF)
        * 可执行文件
        * ...
* 文件共享 & 访问控制
    * 多用户系统
    * 访问控制
        * 每个用户能获得哪些文件的哪些访问权限
        * 访问模式：读、写、执行、删除、列表...
    * 文件访问控制列表(ACL)
        * `<文件实体，权限>`
    * Unix的ACL
        * `<用户|组|所有人，读|写|可执行>`
        * 用户标识ID
        * 用户组标识ID
* 语义一致性
    * 规定多进程如何同时访问共享文件
        * 与同步算法相似
        * 因磁盘I/O和网络延迟而设计简单
    * Unix文件系统语义
        * 对打开文件的**写入内容**立即对其他打开**同一文件的其他用户**可见
        * 共享文件指针允许多用户同时读取和写入文件
    * 会话语义
        * 写入内容只有当文件关闭后才可见
    * 读写锁

#### 目录 & 文件别名 & 文件系统种类
* 文件以目录的方式组织起来
* 目录是一种特殊的文件
    * 目录的内容是文件索引表`<文件名，指向文件的指针>`
* 目录操作
    * 搜索文件、创建文件、删除文件、列目录、重命名文件、遍历路径
    * 对文件进行上述某些操作后，要修改文件索引表的内容
    * 操作系统应该只允许内核修改目录
        * 确保映射完整
        * 应用程序通过系统调用访问目录
* 目录实现
    * 文件名的线性表，包括了指向数据块的指针
        * 简单
        * 耗时长
    * 哈希表
        * 减少了目录的搜索时间
        * 冲突，两个文件哈希值相同
        * 固定大小
* 文件别名
    * 不进行拷贝操作
    * **硬链接**
    * **软链接**
* 文件目录的循环
    * 子目录指回上级目录
    * 防止循环的解决方案
        * 只允许到文件的链接，不允许在子目录的链接
        * 增加链接时，用检测算法确定是否合理
        * 限制路径的可遍历文件目录的数量
* 路径遍历（名字解析）
    * 把路径的逻辑名转换成物理资源
        * 依据路径名，在文件系统中找到实际文件位置
        * 遍历文件目录直到找到目录文件
    * 比如`/bin/ls`
        * 读取根目录的文件头
            * 根目录在磁盘的固定位置
        * 读取根目录的数据块（所有文件和子目录列表），搜索`bin`项
        * 读取`bin`的文件头
        * 读取`bin`的数据块，搜索`ls`项
        * 读取`ls`的文件头
    * 当前工作目录`PWD`
        * 每个进程都会被设定一个缺省文件目录用于解析文件名
* 文件系统挂载
    * 文件系统需要先挂载才能被访问
* 文件系统种类
    * 磁盘文件系统
        * FAT, NTFS, ext2/3, ISO...
    * 数据库文件系统
    * 日志文件系统
    * 网络/分布式文件系统
    * 特殊/虚拟文件系统

#### 虚拟文件系统
* 对所有不同文件系统的抽象
* 功能
    * 提供相同的文件和文件系统接口
    * 管理所有文件和文件系统关联的数据结构
    * 高效查询例程，遍历文件系统
    * 与特定文件系统模块的交互
* 基本数据结构
    * 文件卷控制块（superblock）
        * 每个文件系统一个
        * 文件系统详细信息
        * 块、块大小、空余块、计数/指针等
    * 目录项（dentry）
        * 每个目录项一个
        * 将目录项数据结构及树形布局编码成树形数据结构
        * 指向文件控制块、父目录、子目录等
    * 文件控制块（inode）
        * 每个文件一个
        * 文件详细信息
        * 访问权限、拥有者、大小、数据块位置等

#### 文件缓存和打开文件
* 数据块缓存
    * 数据块按需读入内存
        * 预读后面的数据块
    * 数据块使用后被缓存
        * 假设数据可能会再次用到
        * 写操作可能被缓存和延迟写入
    * 两种数据块缓存方式
        * **数据块缓存**
        * **页缓存**
* 文件系统中打开文件的数据结构
    * 文件描述符
        * 每个被打开的文件都有一个文件描述符
        * 文件状态信息
            * 目录项、当前文件指针、文件操作设置等
    * 打开文件表
        * 每个进程一个打开文件表
        * 一个系统级的打开文件表
        * 有文件被打开时，文件卷就不能被卸载
* 打开文件锁
    * 用于协调多进程的文件访问
    * **强制**
    * **劝告**

#### 文件分配
* 如何表示分配给一个文件的**数据块的位置和顺序**
* 分配方式
    * 连续分配
        * 文件头指定起始块和长度
        * 优点
            * 文件读取速度快
            * 高效顺序和随机访问
        * 缺点
            * 碎片
            * 文件增长麻烦
    * 链式分配
        * 文件头包含了到第一块和最后一块的指针
        * 优点
            * 创建、增长、缩小容易
            * 没有碎片
        * 缺点
            * 无法实现随机访问
            * 可靠性差，破坏一个节点，后面全部无法读取
    * 索引分配
        * 为每个文件创建一个**索引数据块**
            * 指向文件的数据块的**指针列表**
        * 文件头包含了索引数据块的指针
        * 优点
            * 创建、增长、缩小容易
            * 没有碎片
            * 支持直接访问
        * 缺点
            * 存储索引数据块的开销大
* 指标
    * 存储效率
        * 外部碎片
    * 读写性能
        * 访问速度

#### 空闲空间管理 & 冗余磁盘阵列RAID
* 空闲空间管理
    * 位图
    * 链表
    * ...
* 磁盘分区
    * 通常磁盘通过分区来最大限度减少寻道时间
* 多磁盘管理
    * 多磁盘可改善
        * 吞吐量（通过并行）
        * 可靠性和可用性（通过冗余）
    * 冗余磁盘阵列（RAID）
        * 多种磁盘管技术
        * `RAID-0, RAID-1, RAID-5`
    * 冗余磁盘阵列实现
        * 软件
            * 操作系统内核和文件卷管理
        * 硬件
            * RAID硬件控制器(I/O)
* RAID-0
    * **磁盘条带化**
    * 把数据分成多个子块，存储在**独立的磁盘**中
    * 通过多个独立磁盘上并行数据块访问提供更大的磁盘带宽
* RAID-1
    * **磁盘镜像**
    * 向两个磁盘写入，从任何一个读取
    * 可靠性成倍增加
    * 读取性能线性增加
* RAID-4
    * **带校验的磁盘条带化**
    * 数据块级的磁盘条带化加转筒奇偶校验磁盘
    * 允许从任意一个故障磁盘中恢复
* RAID-5
    * **带分布式校验的磁盘条带化**
    * 减少对校验和所在磁盘的读写压力


### I/O子系统

#### I/O特征
* 三种常见设备接口类型
    * 字符设备
        * 键盘、鼠标、串口...
        * 访问特征
            * 以**字节**为单位顺序访问
        * I/O命令
            * get(), put()...
            * **通常使用文件访问接口和语义**
    * 块设备
        * 磁盘驱动器、磁带驱动器、光驱...
        * 访问特征
            * 以**数据块**为单位访问
        * I/O命令
            * 原始I/O或文件系统接口
            * 内存映射文件访问
    * 网络设备
        * 以太网、无线网、蓝牙...
        * 访问特征
            * 格式化报文交换
        * I/O命令
            * send/receive网络报文
            * 通过网络接口支持多种网络协议
* 阻塞I/O
    * 读写数据时，进程进入等待，直到完成读写
* 非阻塞I/O
    * 立即从read/write系统调用返回，返回值为成功传输字节数
* 异步I/O
    * 使用指针标记好缓冲区，立即返回，内核处理完成后通知用户

#### I/O结构
* 北桥
    * 和高速设备相连
    * 内存
    * 显卡
    * ...
* 南桥
    * 和低速I/O设备相连
    * PCI总线
    * 磁盘
    * 网络
    * ...
* CPU与设备的连接
    * 设备控制器
        * 总线接口
        * 硬件控制器
        * 寄存器
        * 内存映射
    * I/O地址
        * I/O指令
        * 内存映射I/O
    * CPU与设备的通信方式
        * 轮询（通过I/O地址）
        * 设备中断（通过中断控制器）
        * DMA控制器
* I/O指令
    * 通过I/O端口号访问设备寄存器
    * 特殊的CPU指令完成对端口的读写
        * `out 0x21, AL`
    * 内存映射I/O
        * 设备的**寄存器/存储**被映射到**物理地址空间**中
        * 通过内存`load/store`指令完成I/O操作
        * MMU设置映射，硬件跳线或程序启动时设备地址
* 内核I/O结构
    * 以鼠标为例
        * 鼠标->鼠标设备控制器->鼠标设备驱动->I/O子系统->内核
* I/O请求周期
    1. I/O请求（用户进程）
    2. 判断是否已有I/O请求结果，有转9（内核I/O子系统）
    3. 向驱动发送I/O请求，并等待结果（内核I/O子系统）
    4. 处理I/O请求，发送控制命令，并等待中断响应（设备驱动）
    5. 控制设备操作（硬件设备）
    6. I/O完成，生成中断请求（硬件设备）
    7. 接收中断，保存结果，并通知设备驱动（中断处理例程）
    8. 确定I/O操作完成状态，通知I/O子系统（设备驱动）
    9. 与进程交换数据，并返回完成结果或错误信息（内核I/O子系统）
    10. I/O操作完成（用户进程）

#### I/O数据传输
* CPU与设备控制器的数据传输
    * 程序控制I/O
        * 通过CPU的`in/out`或者`load/store`传输所有数据
        * 特征
            * 编程容易
            * 消耗的CPU时间和数据量成正比
        * 适用于简单的、小型的设备I/O
    * 直接内存访问（DMA）
        * 设备控制器直接访问系统总线
        * 控制器直接与内存互信传输数据
        * 特征
            * 设备传输数据不影响CPU
            * 但开始和结束需要CPU参与设置
        * 适用于高吞吐量I/O
* I/O设备通知操作系统的机制
    * 操作系统需要了解设备状态
        * I/O完成时间
        * I/O遇到错误
    * 两种方式
        * **CPU主动轮询**
        * **设备中断**
* 轮询
    * I/O设备在特定**状态寄存器**中放置状态和错误信息
    * 操作系统定期检测状态寄存器
    * 特征
        * 简单
        * I/O操作频繁或不可预测时，开销大或延时长
* 设备中断
    * 处理流程
        * CPU在I/O前设置任务参数
        * CPU发出I/O请求后，继续执行其他任务
        * I/O设备处理I/O请求
        * I/O设备完成处理时，触发CPU中断请求
        * CPU接收中断，分发到相应的中断处理例程
    * 特征
        * 处理不可预测事件效果好
        * 如果中断过多，开销较高

#### 磁盘调度
* 寻道时间
    * 定位到期望的磁道所花费的时间
* 旋转延迟
    * 从零扇区开始出到达目的地花费的时间
    * 平均旋转时间 = 磁盘旋转一周的时间 / 2
* 磁盘I/O传输时间
    1. 设备等待可用
    2. 等待通道可用
    3. 寻道时间
    4. 旋转延时
    5. 数据传输
* 磁盘调度算法
    * 通过优化磁盘访问请求顺序（寻道）来提高磁盘访问性能
        * 寻道是磁盘访问最耗时的部分
        * 同时会有多个在同一磁盘上的I/O请求
        * 随机处理磁盘访问请求的性能表现很差
    * 先进先出算法（FIFO）
        * 按顺序处理请求
        * 公平对待所有进程
        * 性能接近随机调度
    * 最短服务时间优先（SSTF）
        * 选择从磁臂**当前位置需要移动最少**的I/O请求
        * 总是选择最短寻道时间
    * 扫描算法（SCAN）
        * **电梯算法**
        * 磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂达到该方向上最后的磁道
        * 调换方向
        * 磁道中间部分的访问性能更好
    * 循环扫描算法（C-SCAN）
        * 限制了仅在一个方向上扫描
        * 当最后一个磁道也被访问过了后，磁臂返回磁盘的另一端再次进行
        * 解决了SCAN里对两边磁道的不如中间部分的访问性能问题，更公平
    * C-LOOK算法
        * 相比C-SCAN，磁臂到达该方向上最后一个请求处，然后立即反转，而不是到达最后一个磁道
    * N-step-SCAN算法
        * 解决磁头粘着现象
            * SSTF，SCAN等算法中，可能出现磁头停留在某处不动的情况
            * 比如进程反复请求对某一磁道的I/O操作
        * 将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列，子队列内部用SCAN
    * FSCAN算法
        * N-step-SCAN的简化
            * 只将请求队列分成两个子队列
        * 把磁盘I/O请求分成两个队列，交替使用扫描算法处理每一个队列。处理某队列时，新生成的请求都被放进另一个队列

#### 磁盘缓存
* 缓存
    * 数据传输双方访问速度差异较大时，引入的速度匹配中间层
* 磁盘缓存是磁盘扇区在内存中的缓存区
    * 磁盘缓存的调度算法类似虚拟存储的调度算法
* 单缓存 & 双缓存
* 访问频率置换算法
    * 问题
        * 密集磁盘访问时，LFU的计数增长过快，无法反映当前的引用情况
    * 思路
        * 考虑磁盘访问的密集特征，对密集引用不计数
        * 在短周期内使用LRU算法，长周期使用LFU算法
    * 实现
        * 把LRU中的特殊栈分成三部分，并在每个缓存块加入引用计数
            * 新区域（栈顶）
            * 中间区域
            * 旧区域（栈底）
        * 栈中缓存块被访问时移到栈顶
            * 如果该块在新区域，引用计数不变。否则引用计数加1
                * 在新区域中引用计数不变的目的是避免密集访问对引用计数快速增加
                * 在中间区域和旧区域增加计数是为了使用LFU
        * 未缓存数据块读入后放在栈顶，引用计数为1
        * 在**旧区域**中**引用计数最小**的缓存块被置换
            * 中间区域的定义就是为了避免新读入的缓存块在第一次出新区域后立即被置换出去，有一个过渡期