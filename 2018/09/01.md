## TCP keepalive && 应用层心跳

#### 背景
* 长连接
    * **避免频繁短链接的三次握手操作**
    * 建立的连接长期保持
    * 短链接：web请求
    * 长连接：数据库连接

* 心跳
    * 给长连接提供**保活**功能
    * 定时向被检测系统发送心跳包，被检测系统收到心跳包进行回复，收到回复说明对方存活

#### TCP SO_KEEPALIVE 对比 应用层心跳
* KeepAlive机制开启后，在一定时间内，在**链路上没有数据传送**的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性

* TCP keepalive缺点
    * 如果TCP连接中的另一方因为停电突然断网，我们并不知道连接断开，此时**发送失败的数据**会进行**重传**，由于重传包的优先级要高于keepalive的数据包，因此**keepalive**的数据包**无法发送**出去。只有在长时间的重传失败之后我们才能判断此连接断开了
    * **keepalive只能检测连接是否存活，不能检测连接是否可用**。比如服务器因为负载过高导致无法响应请求但是连接仍然存在，此时keepalive无法判断连接是否可用
    
* 应用层心跳可以解决上述问题

* tcp keepalive检查连接是否存活。
* 应用keppalive检测应用是否正常可响应

#### Reference
* [长连接和心跳的那些事儿](https://www.jianshu.com/p/c6af08f853d0)
* [TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制??](https://www.zhihu.com/question/40602902)