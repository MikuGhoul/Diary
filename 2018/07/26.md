## 《Linux 内核设计与实现》读书笔记

* 进程调度
    * 在可运行态进程之间分配有限的处理器时间资源的内核子系统

#### Linux的进程调度
* CFS (Completely Fair Scheduler)

#### 调度策略
* 两种进程
    * I/O消耗型（GUI程序）
        * 大部分时间用来提交I/O请求或等待I/O请求，经常堵塞（I/O指任何可堵塞资源）
    * 处理器消耗型（数学计算）
        * 大部分时间都用来执行代码，没有太多I/O请求

* 进程优先级
    * nice值
        * 高nice值，低优先级
        * 低nice值，高优先级
        * Unix中nice值代表分配给进程的时间片的绝对值
        * Linux中nice值代表时间片的比例
    * 实时优先级

* 时间片
    * 进程在被抢占前所能持续运行的时间
    * 调度策略必须规定一个默认的时间片
        * 时间长，交互不好
        * 时间短，增大进程切换的处理器耗时
    * I/O消耗型进程不需要太长的时间片
    * 处理器消耗型进程希望时间片越长越好（减少cache miss）
    * Linux的CFS调度器没有直接分配时间片到进程，而是将处理器的使用比分配给了进程，这样可以让进程获得的处理器时间和系统负载相关（nice值作为权重调整进程所使用的处理器时间使用比）
    * 若新的可运行的进程消耗的处理器使用比比当前进程小，则可以抢占
* 调度策略活动例子
    * 有两个进程，一个是文字编辑程序，一个是视频编解码程序
    * 文字编辑是I/O消耗型
        * 大部分时间在等待用户键盘输入，但用户希望按键后立刻响应
    * 视频编码是处理器消耗型
        * 大部分时间都在编码，但对于运行时间没有特殊要求
    * 理想的情况是调度器给文本编辑程序更多的处理器时间，因为是交互式应用
        * 并非文本编辑程序需要这么多时间，而是希望在它需要时总能得到处理器
    * 大多数操作系统中上述目标的达成是依靠系统分配给文本编辑程序更高的优先级和更多的时间片
    * Linux的方法是不分配给定的优先级和时间片，而是分配一个给定的处理器使用比。如果仅有的这两个进程具有相同的nice值，那么处理器的使用比都是50%
        * 但文字编辑程序肯定不会用到处理器的50%，视频编解码肯定会使用超过50%
        * 一旦文字编辑程序被唤醒，CFS注意到给它的处理器使用比是50%，但是实际使用的很少，为了公平会立刻抢占视频编解码程序
        * 文字编辑程序处理完用户输入后，又一次进入睡眠等待下次输入，因为没有消耗掉承若给的50%处理器使用比，因此下一次CFS还是会让文字编辑程序立刻抢占

#### Linux调度算法
* 调度器类
    * Linux调度器以模块提供，称为调度器类，允许多种不同的可动态添加调度算法并存，调度属于自己范畴的进程。基础的调度器按照优先级顺序遍历调度器类，此调度器类再去选择下面的进程

#### Linux调度实现
* 时间记账
    * 调度器实体结构
        * `<linux/sched.h>`中的`struct_sched_entity`
        * 作为成员变量`se`存储在进程描述符`task_struct`中
    * 虚拟实时
        * vruntime存放进程的虚拟运行时间
        * `<linux/sched_fair.c>`中的`update_curr()`实现记账功能
            * 由系统定时器周期性调用
* 进程选择
    * CFS选择下一个进程时，会选择最小vruntim的进程
    * CFS用红黑树来组织可运行进程队列
* 调度器入口
    * `<linux/sched.h>`中的`schedule()`
    * 找到一个最高优先级的调度类，后者应该有自己的可运行队列，然后询问其谁是下一个该运行的进程
* 睡眠和唤醒

#### 抢占和上下文
* 上下文切换
    * 由定义在`<linux/sched.h>`中的`context_switch()`函数负责，当`schedule()`中选出新的进程后就会调用此函数
        * 会调用`<asm/mmu_context.h>`中的`switch_mm()`，该函数把虚拟内存从上一个进程映射切换到新进程中
        * 会调用`<asm/system.h>`中的`switch_to()`，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态
* 内核必须知道在什么时候调用`schedule()`
    * 内核提供了一个`need_resched`标志来表明是否需要重新执行调度
    * 当某个进程被抢占时，`scheduler_tick()`会设置这个标志
    * 当一个优先级高的进程进入可执行状态时，`try_to_wake_up()`也会设置这个标志，内核检查该标志，确认被设置，调用`schedule()`来切换到一个新的进程
    * 在返回用户空间以及从中断程序返回时，内核也会检查`need_resched`标志，如果被设置，会执行调度程序
    * 每个进程都包含`need_resched`，在`thread_info`中
* 用户抢占
    * 产生时机
        * 在内核返回用户空间时
        * 从中断返回用户空间时
* 内核抢占
    * 只要重新调度是安全的，内核就可以抢占
        * 安全是指没有锁
    * 实现
        * 在`thread_info`中引入`preempt_count`计数器，初始化为0，当使用锁的时候数值加1，释放锁的时候数值减1
        * 数值为0表示可以抢占
    * 从中断返回内核空间时，内核会检查`need_resched`和`preempt_count`   
    * 产生时机
        * 中断处理程序正在执行，且返回内核空间之前
        * 内核代码再一次具有可抢占性的时候
        * 内核中的任务显示调用`schedule()`
        * 内核中的任务堵塞
            * 也会导致调用`schedule()`

#### 实时调度策略
* `<kernel/sched_rt.c>`
    * `SCHED_FIFO`
    * `SCHED_RR`
