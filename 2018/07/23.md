## 《Linux 内核设计与实现》读书笔记

* 进程管理

#### 进程

* 进程
    * 就是处于执行期的程序。但进程并不仅仅局限于一段可执行程序的代码（.text），通常还包括其他资源（打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或多个线程，存放全局变量的数据段等）
* 线程
    * 在进程中活动的对象，每个独立的线程都有一个独立的线程计数器、进程栈和一组进程寄存器，内核的调度对象时线程而不是进程
* 两种虚拟机制
    1. 虚拟处理器
        * 虽然可能是许多进程共享一个处理器，但给进程一种假象，让每个进程觉得自己独享处理器
    2. 虚拟内存
        * 让进程觉得自己拥有整个系统的全部内存资源
    * 在线程之间
        * 可以共享虚拟内存，但每个都拥有自己的虚拟处理器

#### 进程描述符

* 内核把进程的列表存放在 “任务队列” 双向链表中，链表的每一项都类型为 `task_struct`，称为进程描述符
    * 定义在 `<linux/sched.h>`
    * 包含一个进程的所有信息
* 分配进程描述符
    * x86架构寄存器较少，没有使用单独的寄存器存放 task_struct 的位置
        * 所以在进程内核栈引入 `thread_info` 结构体，放在栈顶或栈底，以便通过栈指针就可以计算 `task_strcut` 的位置
    * `current`宏
        * 不同的架构的实现不同，x86把栈指针的后13位屏蔽，用来计算 `thread_info` 的偏移
        * PowerPC架构上有独立的寄存器存放 `task_strct`，current 的实现就可以直接读寄存器中的值
* 进程状态
    * 由 task_struct 中的 state 描述
    * 设置进程状态
        * `set_task_stata(task, state) 和 set_current_state(state)`
* 进程创建
    * 许多其他系统提供了产生进程的机制
        * 在新的地址空间里创建进程，读入可执行文件，最后开始执行
    * Unix 产生进程分为两步
        1. fork()
            * 拷贝当前进程创建一个子进程，子进程与父进程的的区别仅在于PID，PPID和某些资源的统计量（挂起的信号等）
        2. exec()
            * 读入可执行文件，并载入地址空间开始运行
    * 写时拷贝
        * 只有在需要写入的时候，数据才会被复制，在此之前，资源被以只读方式共享
        * 速度优化
    * fork()
        * Linux 通过 `clone()` 系统调用实现 `fork(), vfork(), __clone()`
        * `clone()` 调用 `do_fork()`
* 线程在Linux中的实现
    * 线程机制提供了在同一程序内共享内存地址空间运行的一组线程，这些线程可以共享打开的文件和其他资源
    * 在Windows上线程是内核专门提供了支持线程的机制
    * 在Linux上从内核角度来看，并没有线程的概念，把所有的线程都当作进程来实现
        * 内核中没有特殊的调度算法和数据结构来管理线程
        * 线程在内核中仅仅是一个与其他进程共享某些资源的进程
        * 每个线程都有自己唯一的 `task_strcut`
    * 创建线程
        * 与创建进程类似，只是在调用 `clone()` 时需要传递一些参数指定需要贡献共享的资源
* 进程终结
    * `exit()` 系统调用等都要调用 `do_exit()`
