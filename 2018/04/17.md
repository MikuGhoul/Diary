## BST && RB-Tree

* 给定一棵树，树的高度决定了所有操作在最坏情况下的性能

#### 二叉查找树
* 优点
    * 结合了**链表**的灵活**插入**和有序**数组**的高效**查找**
* 缺点
    * 最坏情况下，性能很差，退化为链表
    
* 使用BST的算法运行时间取决于树的形状
    * 最好的情况
        * N个节点完全平衡，每个叶子节点到根的距离~lg N
    * 最坏的情况
        * N个节点的树高度为N
* 遍历，查找，插入，删除这些操作，用递归写起来非常方便

#### 平衡二叉树
* 优点
    * N个节点的树，树高~lg N，运行时间也就是对数级别
* 缺点
    * 为了维护树的完美平衡的代价很大
* [2-3查找树](https://en.wikipedia.org/wiki/2%E2%80%933_tree)
    * 2-节点
        * 1个键，2条链接（边）
    * 3-节点
        * 2个键，3条边
* 完美平衡的2-3查找树的所有**空链接**到**根节点**的距离都是**相同**的
* 插入
    * **插入就是进行一次未命中的查找，然后把新节点挂在树的底部**，但2-3树要为了维持平衡进行特殊操作
    * 向2-节点中插入
        * 直接把2-节点替换为3-节点
    * 向3-节点中插入
        * 向父节点为2-节点的3-节点插入
            * 构造一个临时的4-节点
            * 然后分解为**3个**2-节点的2-3树
            * 把分解出来的**中键**节点**加入**至**父节点**中，使2-父节点变为3-父节点
        * 向父节点为3-节点的3-节点插入
            * 和上面一样，只是父节点会变成4-节点，然后继续重复分解，向上插入...
            * 如果向上插入到**根节点**，分解出来的中键会使树**高度 +1**
* 标准的BST是**由上向下**成长，而2-3树是**由下向上**成长
* 例子
    * 含有**10亿**个节点的一棵2-3树的高度仅在**19-30**之间
        * 这意味着最多只需访问30个节点就能在10亿个键中进行任意查找和插入

#### 红黑树

* <<算法4>>里用红黑树模拟的2-3树，但目前的应用大多指2-3-4树，下面先以2-3树的模拟来说

* 2-3树的实际实现是比较复杂的，因为需要处理的情况太多，而且频繁进行节点类型转换，额外消耗较大
* 红黑树是2-3树的一种简单模拟
    * 用 **标准BST** (完全由2-节点构成) + **一些额外信息** (替换3-节点) 来表示**2-3树**
        * 额外信息
            * 红链接（或者用**红节点**表示指向这个节点的链接是红链接，下同）
                * 将**BST的两个2-节点**连接起来构成**2-3树的一个3-节点**
            * 黑链接
                * 2-3树中的普通链接
* 另一种等价的定义
    * **红链接**均为**左链接**
    * 没有任何一个节点同时与两条红链接相连
    * 该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同

* 旋转
    * 旋转是红黑树插入，删除的基础
    * 分为左旋，右旋两种

* 插入
    * 向2-节点插入
        1. 插在2-节点的左边，将2-节点变为3-节点
        2. 插在2-节点的右边，左旋，得到正常的3-节点
    * 向3-节点插入
        1. 插入的键最大
            * 会产生两个红链接，让两个红链接变为黑链接，再让他俩的爸爸变红
        2. 插入的键最小
            * 会产生两个红链接，右旋，变成了状态1
        3. 插入的键在二者之间 
            * 会产生两个红链接，左旋，变为状态2

* 模拟2-3-4树的红黑树实现
    * 定义
        * 节点是红色或黑色
        * 根是黑色
        * 所有叶子都是黑色（叶子是NIL节点）
        * 每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）
        * 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
    * 这些约束确保了红黑树的关键特性：**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。
    * 结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树
    

#### Reference
* <<算法4>>