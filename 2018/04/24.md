#### SSL / TSL 原理总结

* 前两篇简单的介绍了**非对称加密**和**数字签名**，这里简单的总结一下

#### 初始场景
* 明文通信(比如http)的缺点
    1. **内容可能第三方被窃听**
    2. **内容可能被第三方篡改**
    3. **第三方可能冒充通信人**
* 例子
    * Client与Server通信，第三方X
    1. X可以窃听数据
    2. X可以篡改数据
    3. X可以冒充Client与Server通信

#### 解决方案
* 加密通信(比如https)
    1. 如何避免被第三方**窃听**（引入**非对称加密**）
        1. Client端的数据用**Server**端的**public key**加密
        2. 发送给Server
        * 只有Server本身持有**Server**的**private key**
        3. 所以Server可以解密数据
        * X即使劫取到数据也**无法解密**
            * 但X可能篡改数据
    2. 如何避免被第三方篡改（引入~~数字签名~~**信息摘要**）
        1. Client的数据用**Server**的**public key**加密
        2. Client把要传送的内容做一下**hash**
            * 得到的hash称为**信息摘要**
        3. 把**信息摘要**放在**数据密文**的后面
        4. 发送给Server
        5. Server端把摘要提取出来
        6. 用**Server**的**private key**对数据密文解密，得到**原明文**
        7. 对**原明文**做一下hash得到**新的摘要**，与发送过来的**原信息摘要**对比，如果相同，就可以证明内容没有被修改过
        * X如果劫取到数据后，篡改了数据的话，Server端再hash的值就很难与摘要的值相同了
            * 很难再碰撞了吧...
    3. 如何避免第三方冒充通信人（引入**数字签名**）
        * 其实上面的过程有点不准确，摘要都是要做数字签名的，我这里分开来说感觉好理解一点
        1. Client的数据用**Server**的**public key**加密
        2. Client把要传送的内容做一下**hash**
            * 得到的hash称为**信息摘要**
        3. 用**Client**的**private key**把**信息摘要加密**
            * 得到的密文称为**数字签名**
        4. 把**数字签名**放在**密文**的后面
        5. 发送给Server
        6. Server端要把数字签名提取出来
        7. 用**Server**的**private key**对数据密文解密，得到**原明文**
        8. 用**Client**的**public key**对数字签名解密，得到**原信息摘要**
        9. 对**原明文**做一下hash得到**新的摘要**，与解密出的**原信息摘要**对比，如果相同，就可以证明内容没有修改过，且**数据是Client发过来的**
            * **因为能被Client的public key解密的数据，只能是Client的private key加密的数据**
                * 这点很重要，留个**flag**

* 接上面的**flag**
    * 假设A有**public key**和**private key**
    * 任何被A的**public key**加密的数据，只能被A的**private key**解密
        * 多对一
        * 一般的场景是任何向A传输数据，用A的**public key**加密，因为只能被A解密
    * 被A的**private key**加密的数据，任何A的**public key**都可以解密
        * 一对多
        * 一般的场景是验证数据来自A，用A的**private key**加密，因为能被解密的数据一定来自A

#### 另一个漏洞
* 公钥分发的问题
    * 如何保证**Client**的**public key**被成功的发送给了**Server**
    * X可以劫取到**Client**的**public key**，然后用X自己的**public key**发送给**Server**
* 解决方案
    * 引入**数字证书**
        * 一个第三方的权威机构（一般为CA）会给**Client**创建一个**数字证书**
            * **Client**的数据被CA获得后，用**CA**的**private key**进行加密，得到**数字证书**
        * 其中包括**Client**的信息以及**Client**的**public key**
    * 有了数字证书之后的流程
        1. **Client**先向**Server**发送自己的**数字证书**
        2. **Server**会向权威机构进行认证，确认是否是**Client**的数字证书
            * **Server**用CA的**public key**解密，若成功，则可以证明此数字证书的确是由CA创建的，可以信任
            * 然后根据解密的信息中提取出**Client**的**public key**
        * 后面的加密，解密步骤就和上面一样了
        
#### Reference
* [RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？](https://www.zhihu.com/question/25912483)
    * **既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证**
* [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)