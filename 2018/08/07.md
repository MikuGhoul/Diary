## 中断 & 异常

* **硬中断**是外部设备对CPU的中断，**软中断**通常是硬中断服务程序对内核的中断，**信号**则是由内核（或其他进程）对某个进程的中断
#### 中断向量
* Intel x86 系列微机共支持256 种向量中断，为使处理器较容易地识别每种中断源，将它们从0～255 编号，即赋予一个中断类型码 n，Intel 把这个8 位的无符号整数叫做一个向量，因此，也叫中断向量

#### 关于中断和异常
* 中断分类
    * 中断
        * INTR（外部可屏蔽中断）
        * NMI（外部非屏蔽中断）
    * 异常
        * Falut
        * Trap
        * Abort

* 中断
    * I/O设备产生的中断请求(IRQ)（如打印机中断）均是可屏蔽中断
    * 紧急事件（如硬件故障，电源掉电等）产生的是非屏蔽中断
* 异常
    * 不使用中断控制器，不能被屏蔽

![级联的8259A的中断机构](https://pic3.zhimg.com/80/v2-6a0e7c1d01bd69e6426ba1e2882ad19f_hd.jpg)
* **CPU每执行完一条指令时，都会检查INTR引脚是否被拉高**

#### 中断描述符表（Interrupt Descriptor Table）
* 每一个中断或异常向量在这个表中有对应的中断或异常处理程序入口地址
* 中断描述符的每一项对应一个中断或异常向量，每个向量由8个字节组成。因此，最多需要256*8=2048字节来存放 IDT    
* CPU 为了防止恶意程序访问中断，限制了中断门的**权限**，而在某些时候，用户程序又必须使用中断，所以 Linux 把中断描述符的中断向量类型改为了5种：**中断门，系统门，系统中断门，陷阱门，任务门**
    * 中断门：Intel的中断门，DPL = 0，描述中断处理程序，通过set_intr_gate宏设置
    * 系统门：Intel的陷阱门，DPL = 3，用于系统调用，通过set_system_gate宏设置
    * 系统中断门：Intel的中断门，DPL = 3，用于向量3的异常处理，通过set_system_intr_gate宏设置
    * 陷阱门：Intel陷阱门，DPL = 0，大部分的异常处理，通过set_trap_gate宏设置
    * 任务门：Intel任务门，DPL = 0，对”Double fault“异常处理，通过set_task_gate宏设置

* 这个中断描述符表的基地址保存在 IDTR 寄存器中。

#### 中断和异常的处理
* 请求中断
    * 当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断控制系统的中断请求触发器置位，向CPU请求中断。系统要求中断请求信号一直保持到CPU对其进行中断响应为止。
* 中断响应
    * CPU对系统内部中断源提出的中断请求必须响应，而且自动取得中断服务子程序的入口地址，执行中断 服务子程序。对于外部中断，CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查询到中断请求信号有效，同时在系统开中断（即IF=1）的情 况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期。
* 关闭中断
    * CPU响应中断后，输出中断响应信号，自动将状态标志寄存器FR或EFR的内容压入堆栈保护起来，然后将FR或EFR中的中断标志位IF与陷阱标志位TF清零，从而自动关闭外部硬件中断。因为CPU刚进入中断时要保护现场，主要涉及堆栈操作，此时不能再响应中断，否则将造成系统混乱。
* 保护断点
    * 保护断点就是将CS和IP/EIP的当前内容压入堆栈保存，以便中断处理完毕后能返回被中断的原程序继续执行，这一过程也是由CPU自动完成。
* 中断源识别
    * 当系统中有多个中断源时，一旦有中断请求，CPU必须确定是哪一个中断源提出的中断请求，并由中断控制器给出中断服务子程序的入口地址，装入CS与IP/EIP两个寄存器。CPU转入相应的中断服务子程序开始执行。
* 保护现场
    * 主程序和中断服务子程序都要使用CPU内部寄存器等资源，为使中断处理程序不破坏主程序中寄存器的内容，应先将断点处各寄存器的内容压入堆栈保护起来，再进入的中断处理。现场保护是由用户使用PUSH指令来实现的。
* 中断服务
    * 中断服务是执行中断的主体部分，不同的中断请求，有各自不同的中断服务内容，需要根据中断源所要完成的功能，事先编写相应的中断服务子程序存入内存，等待中断请求响应后调用执行。
* 恢复现场
    * 当中断处理完毕后，用户通过POP指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值。
* 中断返回
    * 在中断服务子程序的最后要安排一条中断返回指令IRET，执行该指令，系统自动将堆栈内保存的 IP/EIP和CS值弹出，从而恢复主程序断点处的地址值，同时还自动恢复标志寄存器FR或EFR的内容，使CPU转到被中断的程序中继续执行。


#### Reference
* [linux中断源码分析 - 概述(一)](https://www.cnblogs.com/tolimit/p/4390724.html)
* [中断机制和中断描述符表、中断和异常的处理](https://blog.csdn.net/jnu_simba/article/details/11722703)
* [中断描述符表](http://guojing.me/linux-kernel-architecture/posts/interrupt-descriptor-table/)
* [linux中断与异常](https://www.cnblogs.com/chengxuyuancc/p/3380922.html)
* [中断处理过程](https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86)